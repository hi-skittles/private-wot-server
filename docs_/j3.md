
# How to Structure Event Examples to Send to the Client

Based on the code analysis, here's a comprehensive guide on how to structure event examples to send to the client.

## General Structure for Sending Events

All events are sent to the client through the `eventsData` dictionary in the player's account. The process involves:

1. **Retrieving current data**
2. **Modifying the data**
3. **Compressing and serializing**
4. **Sending to client**
5. **Updating the database**

## Basic Pattern for Sending Events

```python
# 1. Retrieve current eventsData
rdata = yield async(StatsHandler.get_stats, cbname='callback')(proxy.normalizedName, 'eventsData')
udata = rdata

# 2. Modify the data for a specific event type
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.EVENT_TYPE] = zlib.compress(cPickle.dumps(
    # Event data structure goes here
))

# 3. Prepare client update data
cdata = {'rev': requestID, 'prevRev': requestID - 1, ('eventsData', '_r'): udata[('eventsData', '_r')]}

# 4. Send to client
proxy.client.update(cPickle.dumps(cdata))
proxy.client.onCmdResponse(requestID, AccountCommands.RES_SUCCESS, '')

# 5. Update database
yield async(StatsHandler.update_stats, cbname='callback')(proxy.normalizedName, udata, ['eventsData'])
```

## Event Type Mapping

Events are categorized using two main enumeration classes:

1. **EVENT_TYPE** (Server-side event types):
   - `ACTION = 1` - Discounts, bonuses, and modifiers
   - `BATTLE_QUEST = 2` - Regular battle quests
   - `TOKEN_QUEST = 3` - Token-based quests
   - `HISTORICAL_BATTLES = 4` - Historical battle events
   - `FORT_QUEST = 5` - Stronghold/Fortress quests
   - `PERSONAL_QUEST = 6` - Personal missions/quests
   - `REF_SYSTEM_QUEST = 7` - Referral system quests
   - `POTAPOV_QUEST = 8` - Potapov (campaign) quests

2. **EVENT_CLIENT_DATA** (Client-side data organization):
   - `ACTION = 1` - Action events data
   - `ACTION_REV = 2` - Action events revision
   - `QUEST = 3` - Regular quests data
   - `QUEST_REV = 4` - Regular quests revision
   - `HISTORICAL_BATTLES = 5` - Historical battles data
   - `HISTORICAL_BATTLES_REV = 6` - Historical battles revision
   - `INGAME_EVENTS = 7` - In-game events data
   - `INGAME_EVENTS_REV = 8` - In-game events revision
   - `NOTIFICATIONS = 9` - Event notifications data
   - `NOTIFICATIONS_REV = 10` - Event notifications revision
   - `PERSONAL_QUEST = 11` - Personal quests data
   - `PERSONAL_QUEST_REV = 12` - Personal quests revision
   - `FORT_QUEST = 13` - Fortress quests data
   - `FORT_QUEST_REV = 14` - Fortress quests revision

## Examples for Different Event Types

### 1. ACTION Event Example

```python
# Structure for ACTION event
action_data = {
    'type': constants.EVENT_TYPE.ACTION,
    'id': 'weekend_special',
    'startTime': 1746490660,  # Unix timestamp
    'finishTime': 1759709860,  # Unix timestamp
    'steps': [
        {
            'name': 'creditsTankmanCost',
            'params': {
                'rate': 0.5  # 50% discount
            }
        },
        {
            'name': 'vehPriceAll',
            'params': {
                'goldPriceMult': 0.85,  # 15% discount on gold prices
                'creditsPriceMult': 0.85  # 15% discount on credit prices
            }
        }
    ]
}

# Send to client
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.ACTION] = zlib.compress(cPickle.dumps(action_data))
```

### 2. BATTLE_QUEST Event Example

```python
# Structure for BATTLE_QUEST event
battle_quest_data = {
    'type': constants.EVENT_TYPE.BATTLE_QUEST,
    'id': 'daily_mission_1',
    'startTime': 1746490660,
    'finishTime': 1746577060,  # 24 hours later
    'conditions': {
        'preBattle': {
            'account': {},  # No account restrictions
            'vehicle': {
                'level': [6, 7, 8, 9, 10],  # Tier 6-10 vehicles
                'classes': ['mediumTank', 'heavyTank']  # Medium and heavy tanks only
            },
            'battle': {
                'bonusTypes': [1]  # Random battles only
            }
        },
        'bonus': {
            'bonusLimit': 3  # Can complete up to 3 times
        },
        'postBattle': {
            'win': True,  # Must win the battle
            'damage': {
                'value': 1500  # Must deal at least 1500 damage
            }
        }
    },
    'bonus': {
        'credits': 25000,
        'xp': 2000
    }
}

# Send to client
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.QUEST] = zlib.compress(cPickle.dumps(battle_quest_data))
```

### 3. TOKEN_QUEST Event Example

```python
# Structure for TOKEN_QUEST event
token_quest_data = {
    'type': constants.EVENT_TYPE.TOKEN_QUEST,
    'id': 'special_token_mission',
    'startTime': 1746490660,
    'finishTime': 1746577060,
    'conditions': {
        'preBattle': {
            'account': {},
            'vehicle': {},
            'battle': {'bonusTypes': [1]}
        },
        'bonus': {'bonusLimit': 1},
        'postBattle': {
            'win': True,
            'alive': True
        }
    },
    'bonus': {
        'tokens': {
            'event_token': {'count': 1}
        }
    }
}

# Send to client
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.QUEST] = zlib.compress(cPickle.dumps(token_quest_data))
```

### 4. HISTORICAL_BATTLES Event Example

```python
# Structure for HISTORICAL_BATTLES event
historical_battle_data = {
    'type': constants.EVENT_TYPE.HISTORICAL_BATTLES,
    'id': 'kursk_1943',
    'startTime': 1746490660,
    'finishTime': 1746577060,
    'arenaTypeID': 45,
    'vehSides': {
        '5393': 'A',  # Soviet T-34
        '6145': 'B'   # German Tiger
    },
    'vehicles': {
        '5393': {
            'ammoList': [[3841, 30], [3843, 20]],  # 30 AP shells, 20 HE shells
            'modules': {
                'gun': 1234,
                'turret': 5678,
                'engine': 9012,
                'chassis': 3456,
                'radio': 7890
            }
        },
        '6145': {
            'ammoList': [[4001, 30], [4003, 20]],
            'modules': {
                'gun': 2345,
                'turret': 6789,
                'engine': 1234,
                'chassis': 5678,
                'radio': 9012
            }
        }
    },
    'localized_data': {
        'title': {'en': 'Battle of Kursk'},
        'shortDescr': {'en': 'Historical recreation of the Kursk battle'},
        'longDescr': {'en': 'Detailed description...'},
        'sideNames': {'A': 'Soviet', 'B': 'German'}
    }
}

# Send to client
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.HISTORICAL_BATTLES] = zlib.compress(cPickle.dumps(historical_battle_data))
```

### 5. INGAME_EVENTS Example

```python
# Structure for INGAME_EVENTS
ingame_events_data = {
    'eventBattles': {
        'vehicleTags': ['halloween'],
        'vehicles': [12345, 67890],
        'enabled': True,
        'arenaTypeID': 100
    }
}

# Send to client
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.INGAME_EVENTS] = zlib.compress(cPickle.dumps(ingame_events_data))
```

### 6. NOTIFICATIONS Example

```python
# Structure for NOTIFICATIONS
notifications_data = [
    {
        'type': 'promo_notification',
        'data': 'special_event_coming',
        'text': {
            'en': 'Special event coming soon!',
            'ru': 'Скоро специальное событие!'
        },
        'requiredTokens': []
    },
    {
        'type': 'cmd_change_hangar',
        'data': 'spaces/hangar_v2',
        'text': {},
        'requiredTokens': []
    }
]

# Send to client
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.NOTIFICATIONS] = zlib.compress(cPickle.dumps(notifications_data))
```

### 7. PERSONAL_QUEST Example

```python
# Structure for PERSONAL_QUEST event
personal_quest_data = {
    'type': constants.EVENT_TYPE.PERSONAL_QUEST,
    'id': 'personal_mission_1',
    'startTime': 1746490660,
    'finishTime': 1777940660,  # Long duration
    'conditions': {
        'preBattle': {
            'account': {},
            'vehicle': {'classes': ['heavyTank']},  # Heavy tanks only
            'battle': {'bonusTypes': [1]}  # Random battles only
        },
        'bonus': {'bonusLimit': 1},  # One-time completion
        'postBattle': {
            'win': True,
            'damage': {'value': 3000},  # Deal 3000+ damage
            'kills': {'value': 3}  # Get 3+ kills
        }
    },
    'bonus': {
        'credits': 100000,
        'items': {'4001': 3},  # 3 premium consumables
        'tankmen': {
            'tmanToken': {
                'nation': 0,  # USSR
                'role': 'commander',
                'skills': ['brotherhood', 'repair'],
                'rankID': 6  # 100% trained
            }
        }
    }
}

# Send to client
udata[('eventsData', '_r')][EVENT_CLIENT_DATA.PERSONAL_QUEST] = zlib.compress(cPickle.dumps(personal_quest_data))
```

## Client-Side Processing

When these events are sent to the client:

1. The client receives the update through the `update` method
2. The `__synchronizeCacheDict` method processes the update and stores it in `eventsData`
3. The `onEventsDataChanged` event is triggered
4. UI components listening for this event update their display
5. The `EventsCache` class decompresses and deserializes the data when needed

## Best Practices

1. **Always include required fields**:
   - `type` - The event type from EVENT_TYPE
   - `id` - Unique identifier for the event
   - `startTime` and `finishTime` - Unix timestamps for event duration

2. **Use the correct EVENT_CLIENT_DATA constant**:
   - Match the event type to the appropriate client data type
   - Remember that each type has a corresponding revision number

3. **Properly compress and serialize**:
   - Always use zlib.compress and cPickle.dumps
   - Follow the established pattern for data transmission

4. **Update the database**:
   - Always call StatsHandler.update_stats after sending to the client
   - This ensures data persistence between sessions

5. **Consider client processing**:
   - The client will decompress and deserialize the data
   - UI components will update based on the event data
   - Time-based events will be invalidated and refreshed automatically

By following these patterns and examples, you can create and send various types of events to the client that will be properly processed and displayed in the game interface.