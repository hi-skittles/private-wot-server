BW.LogQueryParser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */

  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }

  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "query": parse_query,
        "query_fragment_or_error": parse_query_fragment_or_error,
        "query_fragment": parse_query_fragment,
        "query_type": parse_query_type,
        "query_type_or_error": parse_query_type_or_error,
        "severity_query": parse_severity_query,
        "severity_range": parse_severity_range,
        "severity_list": parse_severity_list,
        "severity_or_error": parse_severity_or_error,
        "severity": parse_severity,
        "source": parse_source,
        "proc_type_query": parse_proc_type_query,
        "proc_type": parse_proc_type,
        "proc_type_or_error": parse_proc_type_or_error,
        "message_query": parse_message_query,
        "category_query": parse_category_query,
        "category": parse_category,
        "category_or_error": parse_category_or_error,
        "close_bracket_or_error": parse_close_bracket_or_error,
        "machine_name_query": parse_machine_name_query,
        "pid_query": parse_pid_query,
        "appid_query": parse_appid_query,
        "appid_or_error": parse_appid_or_error,
        "date_query": parse_date_query,
        "datetime_expression": parse_datetime_expression,
        "specific_date_expression": parse_specific_date_expression,
        "server_startup_expression": parse_server_startup_expression,
        "beginning_of_logs_expression": parse_beginning_of_logs_expression,
        "now_expression": parse_now_expression,
        "period_expression": parse_period_expression,
        "period_direction": parse_period_direction,
        "period_magnitude": parse_period_magnitude,
        "period_unit": parse_period_unit,
        "comparison_op": parse_comparison_op,
        "logical_op": parse_logical_op,
        "comma": parse_comma,
        "not_op": parse_not_op,
        "identifier": parse_identifier,
        "string": parse_string,
        "regexp": parse_regexp,
        "nonzero_unsigned_integer": parse_nonzero_unsigned_integer,
        "ws": parse_ws
      };

      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }

      var pos = { offset: 0, line: 1, column: 1, seenCR: false };
      var reportFailures = 0;
      var rightmostFailuresPos = { offset: 0, line: 1, column: 1, seenCR: false };
      var rightmostFailuresExpected = [];
      var cache = {};

      function padLeft(input, padding, length) {
        var result = input;

        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }

        return result;
      }

      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;

        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }

        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }

      function clone(object) {
        var result = {};
        for (var key in object) {
          result[key] = object[key];
        }
        return result;
      }

      function advance(pos, n) {
        var endOffset = pos.offset + n;

        for (var offset = pos.offset; offset < endOffset; offset++) {
          var ch = input.charAt(offset);
          if (ch === "\n") {
            if (!pos.seenCR) { pos.line++; }
            pos.column = 1;
            pos.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            pos.line++;
            pos.column = 1;
            pos.seenCR = true;
          } else {
            pos.column++;
            pos.seenCR = false;
          }
        }

        pos.offset += n;
      }

      function matchFailed(failure) {
        if (pos.offset < rightmostFailuresPos.offset) {
          return;
        }

        if (pos.offset > rightmostFailuresPos.offset) {
          rightmostFailuresPos = clone(pos);
          rightmostFailuresExpected = [];
        }

        rightmostFailuresExpected.push(failure);
      }

      function parse_start() {
        var cacheKey = "start@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        pos0 = clone(pos);
        result0 = parse_query();
        if (result0 !== null) {
          result0 = (function(offset, line, column, q) { query.ast = q; return query; })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_query() {
        var cacheKey = "query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3;
        var pos0, pos1;

        pos0 = clone(pos);
        result0 = parse_query_fragment();
        if (result0 !== null) {
          result1 = [];
          pos1 = clone(pos);
          result2 = parse_logical_op();
          if (result2 !== null) {
            result3 = parse_query_fragment_or_error();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = clone(pos1);
            }
          } else {
            result2 = null;
            pos = clone(pos1);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = clone(pos);
            result2 = parse_logical_op();
            if (result2 !== null) {
              result3 = parse_query_fragment_or_error();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = clone(pos1);
              }
            } else {
              result2 = null;
              pos = clone(pos1);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_query_fragment_or_error() {
        var cacheKey = "query_fragment_or_error@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        reportFailures++;
        result0 = parse_query_fragment();
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.length > pos.offset) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, c) { throw new BW.LogQueryParser.SyntaxError( ["query expression"], c, offset, line, column ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("query expression");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_query_fragment() {
        var cacheKey = "query_fragment@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1;
        var pos0;

        pos0 = clone(pos);
        result0 = parse_not_op();
        if (result0 !== null) {
          result1 = parse_query_type_or_error();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }
        if (result0 === null) {
          result0 = parse_query_type();
          if (result0 === null) {
            result0 = parse_date_query();
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_query_type() {
        var cacheKey = "query_type@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;

        result0 = parse_severity_query();
        if (result0 === null) {
          result0 = parse_source();
          if (result0 === null) {
            result0 = parse_proc_type_query();
            if (result0 === null) {
              result0 = parse_message_query();
              if (result0 === null) {
                result0 = parse_category_query();
                if (result0 === null) {
                  result0 = parse_machine_name_query();
                  if (result0 === null) {
                    result0 = parse_pid_query();
                    if (result0 === null) {
                      result0 = parse_appid_query();
                    }
                  }
                }
              }
            }
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_query_type_or_error() {
        var cacheKey = "query_type_or_error@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        result0 = parse_query_type();
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.length > pos.offset) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, c) { throw new BW.LogQueryParser.SyntaxError( ["query expression"], c, offset, line, column ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_severity_query() {
        var cacheKey = "severity_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;

        reportFailures++;
        result0 = parse_severity_range();
        if (result0 === null) {
          result0 = parse_severity_list();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("severity list or range");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_severity_range() {
        var cacheKey = "severity_range@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1;
        var pos0, pos1;

        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_comparison_op();
        if (result0 !== null) {
          result1 = parse_severity_or_error();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, op, x) { query.params.severity = filterRange( op, x.toUpperCase(), severities ); return [op, x]; })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_severity_list() {
        var cacheKey = "severity_list@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3;
        var pos0, pos1;

        pos0 = clone(pos);
        result0 = parse_severity();
        if (result0 !== null) {
          result1 = [];
          pos1 = clone(pos);
          result2 = parse_comma();
          if (result2 !== null) {
            result3 = parse_severity_or_error();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = clone(pos1);
            }
          } else {
            result2 = null;
            pos = clone(pos1);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = clone(pos);
            result2 = parse_comma();
            if (result2 !== null) {
              result3 = parse_severity_or_error();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = clone(pos1);
              }
            } else {
              result2 = null;
              pos = clone(pos1);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_severity_or_error() {
        var cacheKey = "severity_or_error@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        result0 = parse_severity();
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.length > pos.offset) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, c) { throw new BW.LogQueryParser.SyntaxError( ["severity"], c, offset, line, column ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_severity() {
        var cacheKey = "severity@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        reportFailures++;
        pos0 = clone(pos);
        if (input.substr(pos.offset, 5).toLowerCase() === "trace") {
          result0 = input.substr(pos.offset, 5);
          advance(pos, 5);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"trace\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos.offset, 5).toLowerCase() === "debug") {
            result0 = input.substr(pos.offset, 5);
            advance(pos, 5);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"debug\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos.offset, 4).toLowerCase() === "info") {
              result0 = input.substr(pos.offset, 4);
              advance(pos, 4);
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"info\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos.offset, 7).toLowerCase() === "warning") {
                result0 = input.substr(pos.offset, 7);
                advance(pos, 7);
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"warning\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos.offset, 5).toLowerCase() === "error") {
                  result0 = input.substr(pos.offset, 5);
                  advance(pos, 5);
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"error\"");
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, x) { return set( 'severity', x.toUpperCase() ); })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("severity");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_source() {
        var cacheKey = "source@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        reportFailures++;
        pos0 = clone(pos);
        if (input.substr(pos.offset, 3).toLowerCase() === "c++") {
          result0 = input.substr(pos.offset, 3);
          advance(pos, 3);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"c++\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return set( 'source', 'C++' ); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.substr(pos.offset, 6).toLowerCase() === "script") {
            result0 = input.substr(pos.offset, 6);
            advance(pos, 6);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"script\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) { return set( 'source', 'Script' ); })(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            pos0 = clone(pos);
            if (input.substr(pos.offset, 6).toLowerCase() === "python") {
              result0 = input.substr(pos.offset, 6);
              advance(pos, 6);
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"python\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset, line, column) { return set( 'source', 'Script' ); })(pos0.offset, pos0.line, pos0.column);
            }
            if (result0 === null) {
              pos = clone(pos0);
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("source type");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_proc_type_query() {
        var cacheKey = "proc_type_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        result0 = parse_proc_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = clone(pos);
          result2 = parse_comma();
          if (result2 !== null) {
            result3 = parse_proc_type_or_error();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = clone(pos1);
            }
          } else {
            result2 = null;
            pos = clone(pos1);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = clone(pos);
            result2 = parse_comma();
            if (result2 !== null) {
              result3 = parse_proc_type_or_error();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = clone(pos1);
              }
            } else {
              result2 = null;
              pos = clone(pos1);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("process type list");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_proc_type() {
        var cacheKey = "proc_type@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        reportFailures++;
        pos0 = clone(pos);
        if (input.substr(pos.offset, 10).toLowerCase() === "serviceapp") {
          result0 = input.substr(pos.offset, 10);
          advance(pos, 10);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"serviceapp\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return set( 'procs', 'ServiceApp' ); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.substr(pos.offset, 10).toLowerCase() === "cellappmgr") {
            result0 = input.substr(pos.offset, 10);
            advance(pos, 10);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"cellappmgr\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) { return set( 'procs', 'CellAppMgr' ); })(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            pos0 = clone(pos);
            if (input.substr(pos.offset, 10).toLowerCase() === "baseappmgr") {
              result0 = input.substr(pos.offset, 10);
              advance(pos, 10);
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"baseappmgr\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset, line, column) { return set( 'procs', 'BaseAppMgr' ); })(pos0.offset, pos0.line, pos0.column);
            }
            if (result0 === null) {
              pos = clone(pos0);
            }
            if (result0 === null) {
              pos0 = clone(pos);
              if (input.substr(pos.offset, 7).toLowerCase() === "cellapp") {
                result0 = input.substr(pos.offset, 7);
                advance(pos, 7);
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"cellapp\"");
                }
              }
              if (result0 !== null) {
                result0 = (function(offset, line, column) { return set( 'procs', 'CellApp' ); })(pos0.offset, pos0.line, pos0.column);
              }
              if (result0 === null) {
                pos = clone(pos0);
              }
              if (result0 === null) {
                pos0 = clone(pos);
                if (input.substr(pos.offset, 7).toLowerCase() === "baseapp") {
                  result0 = input.substr(pos.offset, 7);
                  advance(pos, 7);
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"baseapp\"");
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset, line, column) { return set( 'procs', 'BaseApp' ); })(pos0.offset, pos0.line, pos0.column);
                }
                if (result0 === null) {
                  pos = clone(pos0);
                }
                if (result0 === null) {
                  pos0 = clone(pos);
                  if (input.substr(pos.offset, 8).toLowerCase() === "loginapp") {
                    result0 = input.substr(pos.offset, 8);
                    advance(pos, 8);
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"loginapp\"");
                    }
                  }
                  if (result0 !== null) {
                    result0 = (function(offset, line, column) { return set( 'procs', 'LoginApp' ); })(pos0.offset, pos0.line, pos0.column);
                  }
                  if (result0 === null) {
                    pos = clone(pos0);
                  }
                  if (result0 === null) {
                    pos0 = clone(pos);
                    if (input.substr(pos.offset, 8).toLowerCase() === "dbappmgr") {
                      result0 = input.substr(pos.offset, 8);
                      advance(pos, 8);
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"dbappmgr\"");
                      }
                    }
                    if (result0 !== null) {
                      result0 = (function(offset, line, column) { return set( 'procs', 'DBAppMgr' ); })(pos0.offset, pos0.line, pos0.column);
                    }
                    if (result0 === null) {
                      pos = clone(pos0);
                    }
                    if (result0 === null) {
                      pos0 = clone(pos);
                      if (input.substr(pos.offset, 5).toLowerCase() === "dbapp") {
                        result0 = input.substr(pos.offset, 5);
                        advance(pos, 5);
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"dbapp\"");
                        }
                      }
                      if (result0 !== null) {
                        result0 = (function(offset, line, column) { return set( 'procs', 'DBApp' ); })(pos0.offset, pos0.line, pos0.column);
                      }
                      if (result0 === null) {
                        pos = clone(pos0);
                      }
                      if (result0 === null) {
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 4).toLowerCase() === "mgrs") {
                          result0 = input.substr(pos.offset, 4);
                          advance(pos, 4);
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"mgrs\"");
                          }
                        }
                        if (result0 !== null) {
                          result0 = (function(offset, line, column) { return ['BaseAppMgr', 'CellAppMgr', 'DBAppMgr'].map( function( x ) { return set( 'procs', x ); } ); })(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                          pos = clone(pos0);
                        }
                        if (result0 === null) {
                          pos0 = clone(pos);
                          if (input.substr(pos.offset, 4).toLowerCase() === "apps") {
                            result0 = input.substr(pos.offset, 4);
                            advance(pos, 4);
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"apps\"");
                            }
                          }
                          if (result0 !== null) {
                            result0 = (function(offset, line, column) { return ['BaseApp', 'CellApp', 'DBApp', 'LoginApp', 'ServiceApp'].map( function( x ) { return set( 'procs', x ); } ); })(pos0.offset, pos0.line, pos0.column);
                          }
                          if (result0 === null) {
                            pos = clone(pos0);
                          }
                          if (result0 === null) {
                            pos0 = clone(pos);
                            if (input.substr(pos.offset, 5).toLowerCase() === "cells") {
                              result0 = input.substr(pos.offset, 5);
                              advance(pos, 5);
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"cells\"");
                              }
                            }
                            if (result0 !== null) {
                              result0 = (function(offset, line, column) { return ['CellAppMgr', 'CellApp'].map( function( x ) { return set( 'procs', x ); } ); })(pos0.offset, pos0.line, pos0.column);
                            }
                            if (result0 === null) {
                              pos = clone(pos0);
                            }
                            if (result0 === null) {
                              pos0 = clone(pos);
                              if (input.substr(pos.offset, 5).toLowerCase() === "bases") {
                                result0 = input.substr(pos.offset, 5);
                                advance(pos, 5);
                              } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"bases\"");
                                }
                              }
                              if (result0 !== null) {
                                result0 = (function(offset, line, column) { return ['BaseAppMgr', 'BaseApp'].map( function( x ) { return set( 'procs', x ); } ); })(pos0.offset, pos0.line, pos0.column);
                              }
                              if (result0 === null) {
                                pos = clone(pos0);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("process type");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_proc_type_or_error() {
        var cacheKey = "proc_type_or_error@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        result0 = parse_proc_type();
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.length > pos.offset) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, c) { throw new BW.LogQueryParser.SyntaxError( ["process type"], c, offset, line, column ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_message_query() {
        var cacheKey = "message_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        reportFailures++;
        pos0 = clone(pos);
        result0 = parse_string();
        if (result0 !== null) {
          result0 = (function(offset, line, column, s) { return set( 'message', s ); })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          result0 = parse_regexp();
          if (result0 !== null) {
            result0 = (function(offset, line, column, r) { setFlag( 'regex' ); return set( 'message', r ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("log message string or regexp");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_category_query() {
        var cacheKey = "category_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        if (input.charCodeAt(pos.offset) === 91) {
          result0 = "[";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ws();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ws();
          }
          if (result1 !== null) {
            result2 = parse_category_or_error();
            if (result2 !== null) {
              result3 = [];
              pos1 = clone(pos);
              result4 = parse_comma();
              if (result4 !== null) {
                result5 = parse_category_or_error();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = clone(pos1);
                }
              } else {
                result4 = null;
                pos = clone(pos1);
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = clone(pos);
                result4 = parse_comma();
                if (result4 !== null) {
                  result5 = parse_category_or_error();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = clone(pos1);
                  }
                } else {
                  result4 = null;
                  pos = clone(pos1);
                }
              }
              if (result3 !== null) {
                result4 = [];
                result5 = parse_ws();
                while (result5 !== null) {
                  result4.push(result5);
                  result5 = parse_ws();
                }
                if (result4 !== null) {
                  result5 = parse_close_bracket_or_error();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = clone(pos0);
                  }
                } else {
                  result0 = null;
                  pos = clone(pos0);
                }
              } else {
                result0 = null;
                pos = clone(pos0);
              }
            } else {
              result0 = null;
              pos = clone(pos0);
            }
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("category list");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_category() {
        var cacheKey = "category@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        reportFailures++;
        pos0 = clone(pos);
        result0 = parse_identifier();
        if (result0 !== null) {
          result0 = (function(offset, line, column, id) { return set( 'category', id ); })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("category");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_category_or_error() {
        var cacheKey = "category_or_error@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        result0 = parse_category();
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.length > pos.offset) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, c) { throw new BW.LogQueryParser.SyntaxError( ["category"], c, offset, line, column ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_close_bracket_or_error() {
        var cacheKey = "close_bracket_or_error@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        if (input.charCodeAt(pos.offset) === 93) {
          result0 = "]";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"]\"");
          }
        }
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.length > pos.offset) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, c) { throw new BW.LogQueryParser.SyntaxError( ["closing bracket"], c, offset, line, column ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_machine_name_query() {
        var cacheKey = "machine_name_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3, result4;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.substr(pos.offset, 8) === "machine(") {
          result0 = "machine(";
          advance(pos, 8);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"machine(\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ws();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ws();
          }
          if (result1 !== null) {
            result2 = parse_identifier();
            if (result2 !== null) {
              result3 = [];
              result4 = parse_ws();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_ws();
              }
              if (result3 !== null) {
                if (input.charCodeAt(pos.offset) === 41) {
                  result4 = ")";
                  advance(pos, 1);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\")\"");
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, m) { return set( 'machine', m ); })(pos0.offset, pos0.line, pos0.column, result0[2]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("machine name expression");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_pid_query() {
        var cacheKey = "pid_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        reportFailures++;
        pos0 = clone(pos);
        result0 = parse_nonzero_unsigned_integer();
        if (result0 !== null) {
          result0 = (function(offset, line, column, pid) { return set( 'pid', pid ); })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("process id");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_appid_query() {
        var cacheKey = "appid_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.charCodeAt(pos.offset) === 48) {
          result0 = "0";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_appid_or_error();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, a) { return set( 'appid', a ); })(pos0.offset, pos0.line, pos0.column, result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("app id");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_appid_or_error() {
        var cacheKey = "appid_or_error@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        result0 = parse_nonzero_unsigned_integer();
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.length > pos.offset) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("any character");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, c) { throw new BW.LogQueryParser.SyntaxError( ["app ID"], c, offset, line, column ); })(pos0.offset, pos0.line, pos0.column, result0);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_date_query() {
        var cacheKey = "date_query@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_datetime_expression();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ws();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ws();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_period_expression();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("date and/or period expression");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_datetime_expression() {
        var cacheKey = "datetime_expression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;

        result0 = parse_specific_date_expression();
        if (result0 === null) {
          result0 = parse_server_startup_expression();
          if (result0 === null) {
            result0 = parse_beginning_of_logs_expression();
            if (result0 === null) {
              result0 = parse_now_expression();
            }
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_specific_date_expression() {
        var cacheKey = "specific_date_expression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.substr(pos.offset, 5) === "date(") {
          result0 = "date(";
          advance(pos, 5);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"date(\"");
          }
        }
        if (result0 !== null) {
          if (/^[^)]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[^)]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[^)]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[^)]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 41) {
              result2 = ")";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, d) { var sec = new Date( d.join( '' ) ).getTime() / 1000;
            if (isNaN( sec ) || !sec) throw new BW.LogQueryParser.SyntaxError( ["valid date"], d[0], offset, line, column );
                                          return set( 'queryTime', sec ); })(pos0.offset, pos0.line, pos0.column, result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("date expression");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_server_startup_expression() {
        var cacheKey = "server_startup_expression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        pos0 = clone(pos);
        if (input.substr(pos.offset, 7) === "startup") {
          result0 = "startup";
          advance(pos, 7);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"startup\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return set( 'queryTime', 'server startup' ); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_beginning_of_logs_expression() {
        var cacheKey = "beginning_of_logs_expression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0, pos1, pos2, pos3;

        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.substr(pos.offset, 9) === "beginning") {
          result0 = "beginning";
          advance(pos, 9);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"beginning\"");
          }
        }
        if (result0 !== null) {
          pos2 = clone(pos);
          reportFailures++;
          pos3 = clone(pos);
          result1 = [];
          result2 = parse_ws();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ws();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 45) {
              result2 = "-";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = clone(pos3);
            }
          } else {
            result1 = null;
            pos = clone(pos3);
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = clone(pos2);
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return set( 'queryTime', 'beginning of logs' ); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_now_expression() {
        var cacheKey = "now_expression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0, pos1, pos2, pos3;

        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.substr(pos.offset, 3) === "now") {
          result0 = "now";
          advance(pos, 3);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"now\"");
          }
        }
        if (result0 !== null) {
          pos2 = clone(pos);
          reportFailures++;
          pos3 = clone(pos);
          result1 = [];
          result2 = parse_ws();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ws();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 43) {
              result2 = "+";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = clone(pos3);
            }
          } else {
            result1 = null;
            pos = clone(pos3);
          }
          reportFailures--;
          if (result1 === null) {
            result1 = "";
          } else {
            result1 = null;
            pos = clone(pos2);
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return set( 'queryTime', 'now' ); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_period_expression() {
        var cacheKey = "period_expression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0;

        pos0 = clone(pos);
        result0 = parse_period_direction();
        if (result0 !== null) {
          result1 = parse_period_magnitude();
          if (result1 !== null) {
            result2 = parse_period_unit();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos0);
            }
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_period_direction() {
        var cacheKey = "period_direction@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        pos0 = clone(pos);
        if (input.substr(pos.offset, 2) === "+-") {
          result0 = "+-";
          advance(pos, 2);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+-\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return set( 'period', 'either side' ); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.charCodeAt(pos.offset) === 43) {
            result0 = "+";
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"+\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) { return set( 'period', 'forwards' );    })(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            pos0 = clone(pos);
            if (input.charCodeAt(pos.offset) === 45) {
              result0 = "-";
              advance(pos, 1);
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset, line, column) { return set( 'period', 'backwards' );   })(pos0.offset, pos0.line, pos0.column);
            }
            if (result0 === null) {
              pos = clone(pos0);
            }
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_period_magnitude() {
        var cacheKey = "period_magnitude@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        pos0 = clone(pos);
        result0 = parse_nonzero_unsigned_integer();
        if (result0 !== null) {
          result0 = (function(offset, line, column, i) { return set( 'periodValue', i ); })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_period_unit() {
        var cacheKey = "period_unit@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;
        var pos0;

        pos0 = clone(pos);
        if (input.charCodeAt(pos.offset) === 115) {
          result0 = "s";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"s\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return set( 'periodUnit', 'seconds' ); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.charCodeAt(pos.offset) === 109) {
            result0 = "m";
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"m\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) { return set( 'periodUnit', 'minutes' ); })(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            pos0 = clone(pos);
            if (input.charCodeAt(pos.offset) === 104) {
              result0 = "h";
              advance(pos, 1);
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"h\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset, line, column) { return set( 'periodUnit', 'hours' ); })(pos0.offset, pos0.line, pos0.column);
            }
            if (result0 === null) {
              pos = clone(pos0);
            }
            if (result0 === null) {
              pos0 = clone(pos);
              if (input.charCodeAt(pos.offset) === 100) {
                result0 = "d";
                advance(pos, 1);
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"d\"");
                }
              }
              if (result0 !== null) {
                result0 = (function(offset, line, column) { return set( 'periodUnit', 'days' ); })(pos0.offset, pos0.line, pos0.column);
              }
              if (result0 === null) {
                pos = clone(pos0);
              }
            }
          }
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_comparison_op() {
        var cacheKey = "comparison_op@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = [];
        result1 = parse_ws();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_ws();
        }
        if (result0 !== null) {
          if (input.substr(pos.offset, 2) === "<=") {
            result1 = "<=";
            advance(pos, 2);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"<=\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos.offset, 2) === ">=") {
              result1 = ">=";
              advance(pos, 2);
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\">=\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos.offset) === 60) {
                result1 = "<";
                advance(pos, 1);
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos.offset) === 62) {
                  result1 = ">";
                  advance(pos, 1);
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">\"");
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result2 = [];
            result3 = parse_ws();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_ws();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, o) { return o; })(pos0.offset, pos0.line, pos0.column, result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comparison operator");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_logical_op() {
        var cacheKey = "logical_op@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1;
        var pos0;

        reportFailures++;
        pos0 = clone(pos);
        result1 = parse_ws();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_ws();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return "<and>"; })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_comma() {
        var cacheKey = "comma@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = [];
        result1 = parse_ws();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_ws();
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos.offset) === 44) {
            result1 = ",";
            advance(pos, 1);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = [];
            result3 = parse_ws();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_ws();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return "<comma>"; })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comma");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_not_op() {
        var cacheKey = "not_op@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2, result3;
        var pos0, pos1;

        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = [];
        result1 = parse_ws();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_ws();
        }
        if (result0 !== null) {
          if (input.substr(pos.offset, 3).toLowerCase() === "not") {
            result1 = input.substr(pos.offset, 3);
            advance(pos, 3);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"not\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_ws();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_ws();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { query.state.negate = true; return "<not>"; })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_identifier() {
        var cacheKey = "identifier@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1;
        var pos0;

        pos0 = clone(pos);
        if (/^[a-zA-Z_]/.test(input.charAt(pos.offset))) {
          result1 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z_]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z_]/.test(input.charAt(pos.offset))) {
              result1 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z_]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, letters) { return letters.join( '' ); })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_string() {
        var cacheKey = "string@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.charCodeAt(pos.offset) === 34) {
          result0 = "\"";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          if (/^[^"]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[^\"]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[^"]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\"]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 34) {
              result2 = "\"";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, id) { return id.join( '' ); })(pos0.offset, pos0.line, pos0.column, result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("string");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_regexp() {
        var cacheKey = "regexp@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0, pos1;

        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.charCodeAt(pos.offset) === 47) {
          result0 = "/";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          if (/^[^\/]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[^\\/]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[^\/]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\/]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 47) {
              result2 = "/";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, re) { return re.join( '' ); })(pos0.offset, pos0.line, pos0.column, result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("regular expression");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_nonzero_unsigned_integer() {
        var cacheKey = "nonzero_unsigned_integer@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0, result1, result2;
        var pos0, pos1;

        pos0 = clone(pos);
        pos1 = clone(pos);
        if (/^[1-9]/.test(input.charAt(pos.offset))) {
          result0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-9]");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[0-9]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[0-9]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, a, b) { return parseInt( a + (b || []).join( '' ) ); })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }

      function parse_ws() {
        var cacheKey = "ws@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }

        var result0;

        reportFailures++;
        if (input.charCodeAt(pos.offset) === 32) {
          result0 = " ";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }

        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  result0
        };
        return result0;
      }


      function cleanupExpected(expected) {
        expected.sort();

        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }




          var query = {
              params: {},         // logviewer query params
              state: {},          // temporary parse state
              ast: null,          // resulting parse AST
          };

          var severities = ['TRACE', 'DEBUG', 'INFO', 'WARNING', 'ERROR'];

          function set( key, value )
          {
              if (query.state.negate)
              {
                  setFlag( "negate_" + key, true );
                  delete query.state.negate;
              }
              else
              {
                  setFlag( "negate_" + key, false );
              }

              query.params[key] = query.params[key] || [];
              query.params[key].push( value );
              return value;
          }

          function setFlag( flag, value )
          {
              query.params[flag] = (value !== undefined) ? value : true;
              return value;
          }

          function filterRange( /*String*/ op, value, valueList )
          {
               var i = valueList.indexOf( value );
               console.assert( i > -1 );

               var comparator;
               eval( 'comparator = function( j ) { return j ' + op + i + '; }' );

               var matchingList = [];
               for (i in valueList)
               {
                   if (!comparator( i )) continue;
                   matchingList.push( valueList[i] );
               }
               return matchingList;
          }


      var result = parseFunctions[startRule]();

      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos.offset === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos.offset < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos.offset === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos.offset !== input.length) {
        var offset = Math.max(pos.offset, rightmostFailuresPos.offset);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = pos.offset > rightmostFailuresPos.offset ? pos : rightmostFailuresPos;

        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }

      return result;
    },

    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };

  /* Thrown when a parser encounters a syntax error. */

  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;

      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }

      foundHumanized = found ? quote(found) : "end of input";

      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }

    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };

  result.SyntaxError.prototype = Error.prototype;

  return result;
})();